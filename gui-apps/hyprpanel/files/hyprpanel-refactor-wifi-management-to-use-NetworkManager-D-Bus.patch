From 9b3961349bc96577ced397b2aa9137056febfadf Mon Sep 17 00:00:00 2001
From: czechbol <adamludes@gmail.com>
Date: Sun, 16 Nov 2025 21:38:55 +0100
Subject: [PATCH] refactor: wifi management to use NetworkManager D-Bus API

---
 .../network/wifi/APStaging/PasswordInput.tsx  |  87 ++-
 .../network/wifi/APStaging/helpers/index.ts   |  27 +-
 .../menus/network/wifi/APStaging/index.tsx    |   3 +
 .../network/wifi/WirelessAPs/AccessPoint.tsx  |  96 ++-
 .../network/wifi/WirelessAPs/Controls.tsx     |  53 +-
 .../menus/network/wifi/WirelessAPs/index.tsx  |  74 +-
 src/services/network/types.ts                 |  89 +++
 src/services/network/wifi.ts                  | 684 ++++++++++++++++--
 8 files changed, 937 insertions(+), 176 deletions(-)

diff --git a/src/components/menus/network/wifi/APStaging/PasswordInput.tsx b/src/components/menus/network/wifi/APStaging/PasswordInput.tsx
index 8d49d3a..77c6010 100644
--- a/src/components/menus/network/wifi/APStaging/PasswordInput.tsx
+++ b/src/components/menus/network/wifi/APStaging/PasswordInput.tsx
@@ -1,39 +1,67 @@
 import { Gtk } from 'astal/gtk3';
 import AstalNetwork from 'gi://AstalNetwork?version=0.1';
-import { Variable } from 'astal';
+import { Variable, bind } from 'astal';
 import { isPrimaryClick } from 'src/lib/events/mouse';
 import { handlePasswordInput } from './helpers';
+import Spinner from 'src/components/shared/Spinner';
 
-export const PasswordInput = ({ connecting, staging }: PasswordInputProps): JSX.Element => {
-    const showPassword = true;
+export const PasswordInput = ({
+    connecting,
+    staging,
+    isConnectingWithPassword,
+}: PasswordInputProps): JSX.Element => {
+    const showPassword = Variable(false);
 
     return (
-        <box className="network-password-input-container" halign={Gtk.Align.FILL} hexpand>
-            <entry
-                className="network-password-input"
-                hexpand
-                halign={Gtk.Align.START}
-                visibility={!showPassword}
-                placeholderText="Enter Password"
-                onKeyPressEvent={(self, event) => {
-                    handlePasswordInput(self, event, staging);
-                }}
-                setup={(self) => {
-                    setTimeout(() => self.grab_focus(), 100);
-                }}
-            />
-            <button
-                className="close-network-password-input-button"
-                halign={Gtk.Align.END}
-                onClick={(_, event) => {
-                    if (isPrimaryClick(event)) {
-                        connecting.set('');
-                        staging.set(undefined);
-                    }
-                }}
-            >
-                <icon className="close-network-password-input-icon" icon="window-close-symbolic" />
-            </button>
+        <box className="network-password-input-container" halign={Gtk.Align.FILL} hexpand vertical>
+            <box visible={bind(isConnectingWithPassword).as((loading) => !loading)}>
+                <entry
+                    className="network-password-input"
+                    hexpand
+                    halign={Gtk.Align.START}
+                    visibility={bind(showPassword)}
+                    placeholderText="Enter Password"
+                    onKeyPressEvent={(self, event) => {
+                        handlePasswordInput(self, event, staging, isConnectingWithPassword);
+                    }}
+                    setup={(self) => {
+                        setTimeout(() => self.grab_focus(), 100);
+                    }}
+                />
+                <button
+                    className="toggle-password-visibility-button"
+                    halign={Gtk.Align.END}
+                    onClick={(_, event) => {
+                        if (isPrimaryClick(event)) {
+                            showPassword.set(!showPassword.get());
+                        }
+                    }}
+                    tooltipText={bind(showPassword).as((show) => (show ? 'Hide password' : 'Show password'))}
+                >
+                    <icon
+                        className="toggle-password-visibility-icon"
+                        icon={bind(showPassword).as((show) =>
+                            show ? 'view-conceal-symbolic' : 'view-reveal-symbolic',
+                        )}
+                    />
+                </button>
+                <button
+                    className="close-network-password-input-button"
+                    halign={Gtk.Align.END}
+                    onClick={(_, event) => {
+                        if (isPrimaryClick(event)) {
+                            connecting.set('');
+                            staging.set(undefined);
+                        }
+                    }}
+                >
+                    <icon className="close-network-password-input-icon" icon="window-close-symbolic" />
+                </button>
+            </box>
+            <box visible={bind(isConnectingWithPassword)} halign={Gtk.Align.START} spacing={8}>
+                <Spinner active halign={Gtk.Align.START} />
+                <label className="dim-label" label="Connecting..." />
+            </box>
         </box>
     );
 };
@@ -41,4 +69,5 @@ export const PasswordInput = ({ connecting, staging }: PasswordInputProps): JSX.
 interface PasswordInputProps {
     staging: Variable<AstalNetwork.AccessPoint | undefined>;
     connecting: Variable<string>;
+    isConnectingWithPassword: Variable<boolean>;
 }
diff --git a/src/components/menus/network/wifi/APStaging/helpers/index.ts b/src/components/menus/network/wifi/APStaging/helpers/index.ts
index a5067df..279cf40 100644
--- a/src/components/menus/network/wifi/APStaging/helpers/index.ts
+++ b/src/components/menus/network/wifi/APStaging/helpers/index.ts
@@ -3,7 +3,6 @@ import { Gdk } from 'astal/gtk3';
 import { Entry } from 'astal/gtk3/widget';
 import AstalNetwork from 'gi://AstalNetwork?version=0.1';
 import { NetworkService } from 'src/services/network';
-import { SystemUtilities } from 'src/core/system/SystemUtilities';
 
 const networkService = NetworkService.getInstance();
 
@@ -11,6 +10,7 @@ export function handlePasswordInput(
     self: Entry,
     event: Gdk.Event,
     staging: Variable<AstalNetwork.AccessPoint | undefined>,
+    isConnectingWithPassword: Variable<boolean>,
 ): void {
     const keyPressed = event.get_keyval()[1];
     const accessPoint = staging.get();
@@ -20,16 +20,21 @@ export function handlePasswordInput(
         return;
     }
 
-    networkService.wifi.connectToAPWithPassword(accessPoint, password).catch((err) => {
-        if (self.is_visible() && self.get_realized()) {
-            self.grab_focus();
-        }
+    isConnectingWithPassword.set(true);
 
-        SystemUtilities.notify({
-            summary: 'Network',
-            body: err.message,
-        });
+    networkService.wifi
+        .connectToAPWithPassword(accessPoint, password)
+        .then(() => {
+            isConnectingWithPassword.set(false);
+        })
+        .catch(() => {
+            // Error notification is already handled by WifiManager._handleConnectionError
+            isConnectingWithPassword.set(false);
+
+            if (self.is_visible() && self.get_realized()) {
+                self.grab_focus();
+            }
 
-        self.text = '';
-    });
+            self.text = '';
+        });
 }
diff --git a/src/components/menus/network/wifi/APStaging/index.tsx b/src/components/menus/network/wifi/APStaging/index.tsx
index 45d9455..fc9f5be 100644
--- a/src/components/menus/network/wifi/APStaging/index.tsx
+++ b/src/components/menus/network/wifi/APStaging/index.tsx
@@ -7,12 +7,14 @@ import { NetworkService } from 'src/services/network';
 
 const networkService = NetworkService.getInstance();
 const astalNetwork = AstalNetwork.get_default();
+const isConnectingWithPassword = Variable(false);
 
 export const APStaging = (): JSX.Element => {
     const stagingBinding = Variable.derive(
         [bind(astalNetwork, 'wifi'), bind(networkService.wifi.staging)],
         () => {
             if (networkService.wifi.staging.get()?.ssid === undefined) {
+                isConnectingWithPassword.set(false);
                 return <box />;
             }
 
@@ -25,6 +27,7 @@ export const APStaging = (): JSX.Element => {
                     <PasswordInput
                         connecting={networkService.wifi.connecting}
                         staging={networkService.wifi.staging}
+                        isConnectingWithPassword={isConnectingWithPassword}
                     />
                 </box>
             );
diff --git a/src/components/menus/network/wifi/WirelessAPs/AccessPoint.tsx b/src/components/menus/network/wifi/WirelessAPs/AccessPoint.tsx
index 1766b43..72f29dd 100644
--- a/src/components/menus/network/wifi/WirelessAPs/AccessPoint.tsx
+++ b/src/components/menus/network/wifi/WirelessAPs/AccessPoint.tsx
@@ -1,22 +1,60 @@
-import { Variable } from 'astal';
+import { bind, Variable } from 'astal';
 import AstalNetwork from 'gi://AstalNetwork?version=0.1';
 import { NetworkService } from 'src/services/network';
-import { Gtk } from 'astal/gtk3';
+import { Astal, Gtk } from 'astal/gtk3';
 import Spinner from 'src/components/shared/Spinner';
 
 const networkService = NetworkService.getInstance();
 const astalNetwork = AstalNetwork.get_default();
 
 export const AccessPoint = ({ connecting, accessPoint }: AccessPointProps): JSX.Element => {
+    const derivedVars: Variable<unknown>[] = [];
+
+    const isActiveVar = Variable.derive(
+        [bind(astalNetwork.wifi, 'activeAccessPoint')],
+        (activeAp) => accessPoint.ssid === activeAp?.ssid,
+    );
+    derivedVars.push(isActiveVar);
+
+    const iconClassVar = Variable.derive([bind(isActiveVar)], (isActive) => {
+        return `network-icon wifi ${isActive ? 'active' : ''} txt-icon`;
+    });
+    derivedVars.push(iconClassVar);
+
+    const showStatusVar = Variable.derive(
+        [bind(isActiveVar), bind(astalNetwork.wifi, 'state')],
+        (isActive, state) => {
+            return isActive && networkService.wifi.isApEnabled(state);
+        },
+    );
+    derivedVars.push(showStatusVar);
+
+    const wifiStatusVar = Variable.derive([bind(astalNetwork.wifi, 'state')], () => {
+        return networkService.wifi.getWifiStatus();
+    });
+    derivedVars.push(wifiStatusVar);
+
+    const showSpinnerVar = Variable.derive(
+        [bind(connecting), bind(astalNetwork.wifi, 'activeAccessPoint'), bind(astalNetwork.wifi, 'state')],
+        (conn, activeAp, state) => {
+            const isConnecting = accessPoint.bssid === conn;
+            const isActive = accessPoint.ssid === activeAp?.ssid;
+            const isDisconnecting = isActive && state === AstalNetwork.DeviceState.DEACTIVATING;
+            return isConnecting || isDisconnecting;
+        },
+    );
+    derivedVars.push(showSpinnerVar);
+
     const ConnectionIcon = (): JSX.Element => {
         return (
             <label
                 valign={Gtk.Align.START}
-                className={`network-icon wifi ${networkService.wifi.isApActive(accessPoint) ? 'active' : ''} txt-icon`}
+                className={bind(iconClassVar)}
                 label={networkService.getWifiIcon(accessPoint.iconName)}
             />
         );
     };
+
     const ConnectionAccessPoint = (): JSX.Element => {
         return (
             <box className="connection-container" valign={Gtk.Align.CENTER} vertical hexpand>
@@ -28,54 +66,48 @@ export const AccessPoint = ({ connecting, accessPoint }: AccessPointProps): JSX.
                     wrap
                     label={accessPoint.ssid ?? ''}
                 />
-                <revealer
-                    revealChild={
-                        networkService.wifi.isApActive(accessPoint) &&
-                        networkService.wifi.isApEnabled(astalNetwork.wifi?.state)
-                    }
-                >
+                <revealer revealChild={bind(showStatusVar)}>
                     <label
                         className="connection-status dim"
                         halign={Gtk.Align.START}
-                        label={networkService.wifi.getWifiStatus()}
+                        label={bind(wifiStatusVar)}
                     />
                 </revealer>
             </box>
         );
     };
 
-    const LoadingSpinner = (): JSX.Element => {
-        return (
-            <revealer
-                halign={Gtk.Align.END}
-                valign={Gtk.Align.CENTER}
-                revealChild={
-                    accessPoint.bssid === connecting.get() || networkService.wifi.isDisconnecting(accessPoint)
-                }
-            >
-                <Spinner
-                    className="spinner wap"
-                    setup={(self: Spinner) => {
-                        self.start();
-                    }}
-                    halign={Gtk.Align.CENTER}
-                    valign={Gtk.Align.CENTER}
-                />
-            </revealer>
-        );
-    };
+    let isDestroying = false;
 
     return (
         <button
             className="network-element-item"
-            onClick={(_, event) => {
+            onClick={(_: Astal.Button, event: Astal.ClickEvent) => {
                 networkService.wifi.connectToAP(accessPoint, event);
             }}
+            setup={(self) => {
+                self.connect('unrealize', () => {
+                    if (!isDestroying) {
+                        isDestroying = true;
+                        // Drop all derived Variables to prevent memory leaks
+                        derivedVars.forEach((v) => v.drop());
+                    }
+                });
+            }}
         >
             <box hexpand>
                 <ConnectionIcon />
                 <ConnectionAccessPoint />
-                <LoadingSpinner />
+                <revealer halign={Gtk.Align.END} valign={Gtk.Align.CENTER} revealChild={bind(showSpinnerVar)}>
+                    <Spinner
+                        className="spinner wap"
+                        setup={(self: Gtk.Spinner) => {
+                            self.start();
+                        }}
+                        halign={Gtk.Align.CENTER}
+                        valign={Gtk.Align.CENTER}
+                    />
+                </revealer>
             </box>
         </button>
     );
diff --git a/src/components/menus/network/wifi/WirelessAPs/Controls.tsx b/src/components/menus/network/wifi/WirelessAPs/Controls.tsx
index 92fd1e7..0774084 100644
--- a/src/components/menus/network/wifi/WirelessAPs/Controls.tsx
+++ b/src/components/menus/network/wifi/WirelessAPs/Controls.tsx
@@ -1,11 +1,14 @@
-import { Variable } from 'astal';
+import { bind, Variable } from 'astal';
 import AstalNetwork from 'gi://AstalNetwork?version=0.1';
 import { Gtk } from 'astal/gtk3';
 import { NetworkService } from 'src/services/network';
 
 const networkService = NetworkService.getInstance();
+const astalNetwork = AstalNetwork.get_default();
 
 export const Controls = ({ connecting, accessPoint }: ControlsProps): JSX.Element => {
+    const derivedVars: Variable<unknown>[] = [];
+
     const DisconnectButton = (): JSX.Element => {
         return (
             <button
@@ -37,18 +40,50 @@ export const Controls = ({ connecting, accessPoint }: ControlsProps): JSX.Elemen
         );
     };
 
+    const showDisconnectVar = Variable.derive(
+        [bind(connecting), bind(astalNetwork.wifi, 'activeAccessPoint')],
+        (conn, activeAp) => {
+            const isActive = accessPoint.ssid === activeAp?.ssid;
+            const notConnecting = accessPoint.bssid !== conn;
+            return isActive && notConnecting;
+        },
+    );
+    derivedVars.push(showDisconnectVar);
+
+    const showForgetVar = Variable.derive(
+        [bind(networkService.wifi.savedNetworks), bind(astalNetwork.wifi, 'activeAccessPoint')],
+        (savedNets, activeAp) => {
+            const isSaved = savedNets.includes(accessPoint.ssid || '');
+            const isActive = accessPoint.ssid === activeAp?.ssid;
+            return isSaved || isActive;
+        },
+    );
+    derivedVars.push(showForgetVar);
+
+    let isDestroying = false;
+
     return (
-        <revealer
-            revealChild={
-                accessPoint.bssid !== connecting.get() && networkService.wifi.isApActive(accessPoint)
-            }
+        <box
             valign={Gtk.Align.START}
+            setup={(self) => {
+                self.connect('unrealize', () => {
+                    if (!isDestroying) {
+                        isDestroying = true;
+                        // Drop all derived Variables to prevent memory leaks
+                        derivedVars.forEach((v) => v.drop());
+                    }
+                });
+            }}
         >
-            <box className={'network-element-controls-container'}>
-                <DisconnectButton />
+            <revealer revealChild={bind(showDisconnectVar)} valign={Gtk.Align.START}>
+                <box className={'network-element-controls-container'}>
+                    <DisconnectButton />
+                </box>
+            </revealer>
+            <revealer revealChild={bind(showForgetVar)} valign={Gtk.Align.START}>
                 <ForgetButton />
-            </box>
-        </revealer>
+            </revealer>
+        </box>
     );
 };
 
diff --git a/src/components/menus/network/wifi/WirelessAPs/index.tsx b/src/components/menus/network/wifi/WirelessAPs/index.tsx
index 6f9f10f..a8a8a82 100644
--- a/src/components/menus/network/wifi/WirelessAPs/index.tsx
+++ b/src/components/menus/network/wifi/WirelessAPs/index.tsx
@@ -9,57 +9,65 @@ import { NetworkService } from 'src/services/network';
 const networkService = NetworkService.getInstance();
 
 export const WirelessAPs = (): JSX.Element => {
-    const wapBinding = Variable.derive(
+    const filteredWAPs = Variable.derive(
         [
             bind(networkService.wifi.staging),
             bind(networkService.wifi.connecting),
             bind(networkService.wifi.wifiAccessPoints),
             bind(networkService.wifi.isWifiEnabled),
         ],
-        () => {
-            const filteredWAPs = networkService.wifi.getFilteredWirelessAPs();
+        () => networkService.wifi.getFilteredWirelessAPs(),
+    );
 
-            if (filteredWAPs.length <= 0 && networkService.wifi.staging.get() === undefined) {
-                return (
-                    <label
-                        className={'waps-not-found dim'}
-                        expand
-                        halign={Gtk.Align.CENTER}
-                        valign={Gtk.Align.CENTER}
-                        label={'No Wi-Fi Networks Found'}
-                    />
-                );
-            }
+    const hasNetworks = Variable.derive(
+        [bind(filteredWAPs), bind(networkService.wifi.staging)],
+        (aps, staging) => {
+            return aps.length > 0 || staging !== undefined;
+        },
+    );
 
-            return (
+    let isDestroying = false;
+
+    return (
+        <box
+            className={'available-waps'}
+            vertical
+            setup={(self: { connect: (arg0: string, arg1: () => void) => void }) => {
+                self.connect('unrealize', () => {
+                    if (!isDestroying) {
+                        isDestroying = true;
+                        filteredWAPs.drop();
+                        hasNetworks.drop();
+                    }
+                });
+            }}
+        >
+            <revealer revealChild={bind(hasNetworks).as((v) => !v)}>
+                <label
+                    className={'waps-not-found dim'}
+                    expand
+                    halign={Gtk.Align.CENTER}
+                    valign={Gtk.Align.CENTER}
+                    label={'No Wi-Fi Networks Found'}
+                />
+            </revealer>
+            <revealer revealChild={bind(hasNetworks)}>
                 <scrollable className={'menu-scroller wap'}>
                     <box className={'available-waps-list'} vertical>
-                        {filteredWAPs.map((ap: AstalNetwork.AccessPoint) => {
-                            return (
-                                <box className={'network-element-item'}>
+                        {bind(filteredWAPs).as((aps) =>
+                            aps.map((ap: AstalNetwork.AccessPoint) => (
+                                <box className={'network-element-item'} key={ap.bssid}>
                                     <AccessPoint
                                         connecting={networkService.wifi.connecting}
                                         accessPoint={ap}
                                     />
                                     <Controls connecting={networkService.wifi.connecting} accessPoint={ap} />
                                 </box>
-                            );
-                        })}
+                            )),
+                        )}
                     </box>
                 </scrollable>
-            );
-        },
-    );
-
-    return (
-        <box
-            className={'available-waps'}
-            vertical
-            onDestroy={() => {
-                wapBinding.drop();
-            }}
-        >
-            {wapBinding()}
+            </revealer>
         </box>
     );
 };
diff --git a/src/services/network/types.ts b/src/services/network/types.ts
index cf04922..9ae44a9 100644
--- a/src/services/network/types.ts
+++ b/src/services/network/types.ts
@@ -1,4 +1,5 @@
 import AstalNetwork from 'gi://AstalNetwork?version=0.1';
+import NM from 'gi://NM?version=1.0';
 
 export type WifiIcon = '󰤩' | '󰤨' | '󰤪' | '󰤨' | '󰤩' | '󰤮' | '󰤨' | '󰤥' | '󰤢' | '󰤟' | '󰤯' | '󰤫';
 
@@ -25,19 +26,107 @@ export const DEVICE_STATES: DevceStates = {
 
 export const wifiIconMap = new Map<string, WifiIcon>([
     ['network-wireless-acquiring', '󰤩'],
+    ['network-wireless-acquiring-symbolic', '󰤩'],
     ['network-wireless-connected', '󰤨'],
+    ['network-wireless-connected-symbolic', '󰤨'],
     ['network-wireless-encrypted', '󰤪'],
+    ['network-wireless-encrypted-symbolic', '󰤪'],
     ['network-wireless-hotspot', '󰤨'],
+    ['network-wireless-hotspot-symbolic', '󰤨'],
     ['network-wireless-no-route', '󰤩'],
+    ['network-wireless-no-route-symbolic', '󰤩'],
     ['network-wireless-offline', '󰤮'],
+    ['network-wireless-offline-symbolic', '󰤮'],
     ['network-wireless-signal-excellent', '󰤨'],
+    ['network-wireless-signal-excellent-symbolic', '󰤨'],
     ['network-wireless-signal-good', '󰤥'],
+    ['network-wireless-signal-good-symbolic', '󰤥'],
     ['network-wireless-signal-ok', '󰤢'],
+    ['network-wireless-signal-ok-symbolic', '󰤢'],
     ['network-wireless-signal-weak', '󰤟'],
+    ['network-wireless-signal-weak-symbolic', '󰤟'],
     ['network-wireless-signal-none', '󰤯'],
+    ['network-wireless-signal-none-symbolic', '󰤯'],
 ]);
 
 export const AP_FLAGS = {
     NONE: 0,
     PRIVACY: 1,
 } as const;
+
+export const AP_SEC_FLAGS = {
+    NONE: 0x0000,
+    PAIR_WEP40: 0x0001,
+    PAIR_WEP104: 0x0002,
+    PAIR_TKIP: 0x0004,
+    PAIR_CCMP: 0x0008,
+    GROUP_WEP40: 0x0010,
+    GROUP_WEP104: 0x0020,
+    GROUP_TKIP: 0x0040,
+    GROUP_CCMP: 0x0080,
+    KEY_MGMT_PSK: 0x0100,
+    KEY_MGMT_802_1X: 0x0200,
+    KEY_MGMT_SAE: 0x0400,
+    KEY_MGMT_OWE: 0x0800,
+    KEY_MGMT_OWE_TM: 0x1000,
+} as const;
+
+export enum SecurityType {
+    OPEN = 'open',
+    OWE = 'owe',
+    WEP = 'wep',
+    WPA_PSK = 'wpa-psk',
+    WPA_ENTERPRISE = 'wpa-eap',
+    WPA3_SAE = 'sae',
+}
+
+/**
+ * Error type classification for WiFi connection failures.
+ */
+export const enum ErrorType {
+    AUTHENTICATION = 'AUTHENTICATION',
+    TIMEOUT = 'TIMEOUT',
+    DEVICE = 'DEVICE',
+    OTHER = 'OTHER',
+}
+
+/**
+ * NetworkManager active connection state reasons that indicate authentication failures.
+ */
+export const AUTH_STATE_REASONS: NM.ActiveConnectionStateReason[] = [
+    NM.ActiveConnectionStateReason.NO_SECRETS,
+    NM.ActiveConnectionStateReason.LOGIN_FAILED,
+];
+
+/**
+ * NetworkManager device state reasons that indicate authentication failures.
+ */
+export const AUTH_DEVICE_REASONS: NM.DeviceStateReason[] = [
+    NM.DeviceStateReason.NO_SECRETS,
+    NM.DeviceStateReason.SUPPLICANT_DISCONNECT,
+    NM.DeviceStateReason.SUPPLICANT_CONFIG_FAILED,
+    NM.DeviceStateReason.SUPPLICANT_FAILED,
+    NM.DeviceStateReason.SUPPLICANT_TIMEOUT,
+    NM.DeviceStateReason.SSID_NOT_FOUND, // Often indicates auth failure when AP rejects connection
+];
+
+/**
+ * NetworkManager device-related connection state reasons.
+ */
+export const DEVICE_STATE_REASONS: NM.ActiveConnectionStateReason[] = [
+    NM.ActiveConnectionStateReason.DEVICE_DISCONNECTED,
+    NM.ActiveConnectionStateReason.DEVICE_REALIZE_FAILED,
+    NM.ActiveConnectionStateReason.DEVICE_REMOVED,
+];
+
+/**
+ * User-friendly error messages for NetworkManager state reasons.
+ */
+export const CONNECTION_ERROR_MESSAGES: Record<number, string> = {
+    [NM.ActiveConnectionStateReason.SERVICE_STOPPED]: 'Network service stopped.',
+    [NM.ActiveConnectionStateReason.IP_CONFIG_INVALID]: 'Invalid IP configuration.',
+    [NM.ActiveConnectionStateReason.SERVICE_START_TIMEOUT]: 'Service failed to start.',
+    [NM.ActiveConnectionStateReason.SERVICE_START_FAILED]: 'Service failed to start.',
+    [NM.ActiveConnectionStateReason.CONNECTION_REMOVED]: 'Connection profile removed.',
+    [NM.ActiveConnectionStateReason.DEPENDENCY_FAILED]: 'Dependency failed.',
+} as const;
diff --git a/src/services/network/wifi.ts b/src/services/network/wifi.ts
index e68eba6..d36bd22 100644
--- a/src/services/network/wifi.ts
+++ b/src/services/network/wifi.ts
@@ -1,9 +1,20 @@
-import { bind, execAsync, Variable } from 'astal';
+import { bind, Variable, GLib } from 'astal';
 import { Astal } from 'astal/gtk3';
 import AstalNetwork from 'gi://AstalNetwork?version=0.1';
+import NM from 'gi://NM?version=1.0';
 import { SystemUtilities } from 'src/core/system/SystemUtilities';
 import { isPrimaryClick } from 'src/lib/events/mouse';
-import { AP_FLAGS, DEVICE_STATES } from './types';
+import {
+    AP_FLAGS,
+    AP_SEC_FLAGS,
+    SecurityType,
+    DEVICE_STATES,
+    ErrorType,
+    AUTH_STATE_REASONS,
+    AUTH_DEVICE_REASONS,
+    DEVICE_STATE_REASONS,
+    CONNECTION_ERROR_MESSAGES,
+} from './types';
 
 /**
  * WifiManager handles all WiFi-related functionality for staging and connecting to
@@ -11,12 +22,15 @@ import { AP_FLAGS, DEVICE_STATES } from './types';
  */
 export class WifiManager {
     private _astalNetwork: AstalNetwork.Network;
+    private _nmClient: NM.Client;
 
     public isWifiEnabled: Variable<boolean> = Variable(false);
     public isScanning: Variable<boolean> = Variable(false);
     public wifiAccessPoints: Variable<AstalNetwork.AccessPoint[]> = Variable([]);
     public staging = Variable<AstalNetwork.AccessPoint | undefined>(undefined);
     public connecting = Variable<string>('');
+    public savedNetworks: Variable<string[]> = Variable([]);
+    public activeConnectionState: Variable<number> = Variable(0);
 
     private _wifiEnabledBinding: Variable<void> | undefined;
     private _scanningBinding: Variable<void> | undefined;
@@ -24,6 +38,41 @@ export class WifiManager {
 
     constructor(networkService: AstalNetwork.Network) {
         this._astalNetwork = networkService;
+        this._nmClient = networkService.client;
+        this._setupNMSignals();
+        this._updateSavedNetworksFromNM();
+    }
+
+    /**
+     * Sets up NetworkManager D-Bus signal subscriptions for real-time updates.
+     * This eliminates the need for polling saved networks.
+     */
+    private _setupNMSignals(): void {
+        this._nmClient.connect('connection-added', () => {
+            this._updateSavedNetworksFromNM();
+        });
+
+        this._nmClient.connect('connection-removed', () => {
+            this._updateSavedNetworksFromNM();
+        });
+
+        this._nmClient.connect('active-connection-added', () => {
+            this.activeConnectionState.set(this.activeConnectionState.get() + 1);
+        });
+
+        this._nmClient.connect('active-connection-removed', () => {
+            this.activeConnectionState.set(this.activeConnectionState.get() + 1);
+        });
+
+        if (this._astalNetwork.wifi) {
+            this._astalNetwork.wifi.connect('notify::active-access-point', () => {
+                this.activeConnectionState.set(this.activeConnectionState.get() + 1);
+            });
+
+            this._astalNetwork.wifi.connect('notify::state', () => {
+                this.activeConnectionState.set(this.activeConnectionState.get() + 1);
+            });
+        }
     }
 
     /**
@@ -33,6 +82,7 @@ export class WifiManager {
         this._wifiEnabled();
         this._scanningStatus();
         this._accessPoints();
+        this._updateSavedNetworksFromNM();
     }
 
     /**
@@ -144,6 +194,17 @@ export class WifiManager {
                     return 1;
                 }
 
+                const aIsSaved = this.isSavedNetwork(a.ssid || '');
+                const bIsSaved = this.isSavedNetwork(b.ssid || '');
+
+                if (aIsSaved && !bIsSaved) {
+                    return -1;
+                }
+
+                if (!aIsSaved && bIsSaved) {
+                    return 1;
+                }
+
                 return b.strength - a.strength;
             });
 
@@ -205,8 +266,250 @@ export class WifiManager {
         return DEVICE_STATES[AstalNetwork.DeviceState.UNKNOWN];
     }
 
+    /**
+     * Updates the list of saved network connections from NetworkManager.
+     * This method is called automatically when connections are added/removed.
+     */
+    private _updateSavedNetworksFromNM(): void {
+        try {
+            const connections = this._nmClient.get_connections();
+            const wifiNetworks = connections
+                .filter((c) => c.get_connection_type() === '802-11-wireless')
+                .map((c) => c.get_id())
+                .filter((name) => name && name.length > 0);
+
+            this.savedNetworks.set(wifiNetworks);
+        } catch (err) {
+            console.error('Error refreshing saved networks from NM:', err);
+            this.savedNetworks.set([]);
+        }
+    }
+
+    /**
+     * Checks if a given SSID has a saved connection profile.
+     *
+     * @param ssid - The SSID to check.
+     * @returns True if the network is saved; otherwise, false.
+     */
+    public isSavedNetwork(ssid: string): boolean {
+        return this.savedNetworks.get().includes(ssid);
+    }
+
+    /**
+     * Gets the WiFi device from NetworkManager.
+     *
+     * @returns The NM.DeviceWifi instance or null if not found.
+     */
+    private _getWifiDevice(): NM.DeviceWifi | null {
+        const devices = this._nmClient.get_devices();
+        const wifiDevice = devices.find((d) => d.get_device_type() === NM.DeviceType.WIFI);
+        return (wifiDevice as NM.DeviceWifi) || null;
+    }
+
+    /**
+     * Gets the D-Bus object path for an access point.
+     * Maps AstalNetwork.AccessPoint to NM.AccessPoint by BSSID.
+     *
+     * @param accessPoint - The AstalNetwork access point.
+     * @returns The D-Bus object path or null if not found.
+     */
+    private _getAPPath(accessPoint: AstalNetwork.AccessPoint): string | null {
+        const wifiDevice = this._getWifiDevice();
+        if (!wifiDevice) {
+            return null;
+        }
+
+        const nmAPs = wifiDevice.get_access_points();
+        const nmAP = nmAPs.find((ap) => ap.get_bssid() === accessPoint.bssid);
+        return nmAP?.get_path() || null;
+    }
+
+    /**
+     * Detects the security type of an access point.
+     *
+     * @param accessPoint - The access point to check.
+     * @returns The security type of the network.
+     */
+    private _detectSecurityType(accessPoint: AstalNetwork.AccessPoint): SecurityType {
+        const { flags, wpaFlags, rsnFlags } = accessPoint;
+
+        if (rsnFlags && rsnFlags !== 0) {
+            if (rsnFlags & AP_SEC_FLAGS.KEY_MGMT_SAE) {
+                return SecurityType.WPA3_SAE;
+            }
+            if (rsnFlags & (AP_SEC_FLAGS.KEY_MGMT_OWE | AP_SEC_FLAGS.KEY_MGMT_OWE_TM)) {
+                return SecurityType.OWE;
+            }
+            if (rsnFlags & AP_SEC_FLAGS.KEY_MGMT_802_1X) {
+                return SecurityType.WPA_ENTERPRISE;
+            }
+            if (rsnFlags & AP_SEC_FLAGS.KEY_MGMT_PSK) {
+                return SecurityType.WPA_PSK;
+            }
+        }
+
+        if (wpaFlags && wpaFlags !== 0) {
+            if (wpaFlags & AP_SEC_FLAGS.KEY_MGMT_802_1X) {
+                return SecurityType.WPA_ENTERPRISE;
+            }
+            if (wpaFlags & AP_SEC_FLAGS.KEY_MGMT_PSK) {
+                return SecurityType.WPA_PSK;
+            }
+        }
+
+        if (flags && flags & AP_FLAGS.PRIVACY) {
+            return SecurityType.WEP;
+        }
+
+        return SecurityType.OPEN;
+    }
+
+    /**
+     * Determines if an access point requires a password for connection.
+     *
+     * @param accessPoint - The access point to check.
+     * @returns True if password is required, false for open/OWE networks.
+     */
+    private _requiresPassword(accessPoint: AstalNetwork.AccessPoint): boolean {
+        const securityType = this._detectSecurityType(accessPoint);
+        return securityType !== SecurityType.OPEN && securityType !== SecurityType.OWE;
+    }
+
+    /**
+     * Deactivates a connection by SSID.
+     *
+     * @param ssid - The SSID of the network to disconnect from.
+     * @returns Promise that resolves when disconnection is complete.
+     */
+    private async _deactivateConnection(ssid: string): Promise<void> {
+        const activeConns = this._nmClient.get_active_connections();
+        const activeConn = activeConns.find((ac: NM.ActiveConnection) => ac.get_id() === ssid);
+
+        if (!activeConn) {
+            return; // No active connection to disconnect
+        }
+
+        return new Promise<void>((resolve, reject) => {
+            this._nmClient.deactivate_connection_async(
+                activeConn,
+                null,
+                (client: NM.Client | null, result) => {
+                    try {
+                        if (client) {
+                            client.deactivate_connection_finish(result);
+                        }
+                        resolve();
+                    } catch (err) {
+                        reject(err);
+                    }
+                },
+            );
+        });
+    }
+
+    /**
+     * Activates an existing saved connection.
+     *
+     * @param ssid - The SSID of the network to activate.
+     */
+    private async _activateExistingConnection(ssid: string): Promise<void> {
+        const connection = this._nmClient.get_connection_by_id(ssid);
+
+        if (!connection) {
+            throw new Error('Connection not found');
+        }
+
+        // Disconnect from current network if switching to a different one
+        const currentSsid = this._astalNetwork.wifi?.activeAccessPoint?.ssid;
+        if (currentSsid && currentSsid !== ssid) {
+            await this._deactivateConnection(currentSsid);
+        }
+
+        return new Promise<void>((resolve, reject) => {
+            this._nmClient.activate_connection_async(
+                connection,
+                null, // device (auto-select)
+                null, // specific_object (AP path)
+                null, // cancellable
+                (client: NM.Client | null, result) => {
+                    try {
+                        if (client) {
+                            client.activate_connection_finish(result);
+                        }
+                        resolve();
+                    } catch (err) {
+                        reject(err);
+                    }
+                },
+            );
+        });
+    }
+
+    /**
+     * Connects to an open WiFi network.
+     *
+     * @param accessPoint - The access point to connect to.
+     */
+    private async _connectToOpenNetwork(accessPoint: AstalNetwork.AccessPoint): Promise<void> {
+        const connection = NM.SimpleConnection.new();
+        const ssid = accessPoint.ssid;
+
+        if (!ssid) {
+            throw new Error('SSID is required');
+        }
+
+        const settingConn = NM.SettingConnection.new();
+        settingConn.id = ssid;
+        settingConn.type = '802-11-wireless';
+        settingConn.uuid = NM.utils_uuid_generate();
+        connection.add_setting(settingConn);
+
+        const settingWireless = NM.SettingWireless.new();
+        const ssidBytes = new TextEncoder().encode(ssid);
+        settingWireless.ssid = GLib.Bytes.new(ssidBytes);
+        connection.add_setting(settingWireless);
+
+        const settingIP4 = NM.SettingIP4Config.new();
+        settingIP4.method = 'auto';
+        connection.add_setting(settingIP4);
+
+        const settingIP6 = NM.SettingIP6Config.new();
+        settingIP6.method = 'auto';
+        connection.add_setting(settingIP6);
+
+        const wifiDevice = this._getWifiDevice();
+        const apPath = this._getAPPath(accessPoint);
+
+        if (!wifiDevice) {
+            throw new Error('WiFi device not found');
+        }
+
+        return new Promise<void>((resolve, reject) => {
+            this._nmClient.add_and_activate_connection_async(
+                connection,
+                wifiDevice,
+                apPath,
+                null,
+                (client: NM.Client | null, result) => {
+                    try {
+                        if (client) {
+                            client.add_and_activate_connection_finish(result);
+                        }
+                        resolve();
+                    } catch (err) {
+                        reject(err);
+                    }
+                },
+            );
+        });
+    }
+
     /**
      * Initiates a connection to the specified access point.
+     * If a saved connection exists, it will be activated.
+     * For new WPA-Enterprise networks, shows "not supported" message.
+     * For new secured networks, opens password prompt.
+     * For new open networks, connects immediately.
      *
      * @param accessPoint - The access point to connect to.
      * @param event - The click event triggering the connection.
@@ -220,10 +523,14 @@ export class WifiManager {
             return;
         }
 
-        if (!accessPoint.flags || accessPoint.flags === AP_FLAGS.NONE) {
-            this.connecting.set(accessPoint.bssid ?? '');
+        const ssid = accessPoint.ssid;
+        if (!ssid) {
+            return;
+        }
 
-            execAsync(`nmcli device wifi connect ${accessPoint.bssid}`)
+        if (this.isSavedNetwork(ssid)) {
+            this.connecting.set(accessPoint.bssid ?? '');
+            this._activateExistingConnection(ssid)
                 .then(() => {
                     this.connecting.set('');
                     this.staging.set({} as AstalNetwork.AccessPoint);
@@ -235,13 +542,42 @@ export class WifiManager {
                         body: err.message,
                     });
                 });
-        } else {
+            return;
+        }
+
+        const securityType = this._detectSecurityType(accessPoint);
+
+        if (securityType === SecurityType.WPA_ENTERPRISE) {
+            SystemUtilities.notify({
+                summary: 'Network',
+                body: 'WPA-Enterprise networks are not supported at the moment.',
+            });
+            return;
+        }
+
+        if (this._requiresPassword(accessPoint)) {
             this.staging.set(accessPoint);
+            return;
         }
+
+        this.connecting.set(accessPoint.bssid ?? '');
+        this._connectToOpenNetwork(accessPoint)
+            .then(() => {
+                this.connecting.set('');
+                this.staging.set({} as AstalNetwork.AccessPoint);
+            })
+            .catch((err: Error) => {
+                this.connecting.set('');
+                SystemUtilities.notify({
+                    summary: 'Network',
+                    body: err.message,
+                });
+            });
     }
 
     /**
-     * Connects to a secured access point with a password.
+     * Connects to a secured access point with a password via D-Bus.
+     * Supports WEP, WPA-PSK, WPA2-PSK, and WPA3-SAE.
      *
      * @param accessPoint - The access point to connect to.
      * @param password - The password for the network.
@@ -255,18 +591,235 @@ export class WifiManager {
         }
 
         this.connecting.set(accessPoint.bssid || '');
+        const ssid = accessPoint.ssid;
+        const securityType = this._detectSecurityType(accessPoint);
 
-        const connectCommand = `nmcli device wifi connect "${accessPoint.ssid}" password "${password}"`;
+        try {
+            const wifiDevice = this._getWifiDevice();
+            const apPath = this._getAPPath(accessPoint);
 
-        return execAsync(connectCommand)
-            .then(() => {
-                this.connecting.set('');
-                this.staging.set(undefined);
-            })
-            .catch((err: Error) => {
-                this.connecting.set('');
-                throw err;
+            if (!wifiDevice || !apPath) {
+                throw new Error('WiFi device or access point not found');
+            }
+
+            if (securityType === SecurityType.WEP) {
+                SystemUtilities.notify({
+                    summary: 'Security Warning',
+                    body: 'WEP encryption is deprecated and insecure. Consider upgrading your router to WPA2/WPA3.',
+                });
+            }
+
+            const connection = NM.SimpleConnection.new();
+
+            const settingConn = NM.SettingConnection.new();
+            settingConn.id = ssid;
+            settingConn.type = '802-11-wireless';
+            settingConn.uuid = NM.utils_uuid_generate();
+            connection.add_setting(settingConn);
+
+            const settingWireless = NM.SettingWireless.new();
+            const ssidBytes = new TextEncoder().encode(ssid);
+            settingWireless.ssid = GLib.Bytes.new(ssidBytes);
+            connection.add_setting(settingWireless);
+
+            const settingSecurity = NM.SettingWirelessSecurity.new();
+
+            if (securityType === SecurityType.WEP) {
+                settingSecurity.key_mgmt = 'none';
+                settingSecurity.auth_alg = 'open';
+                settingSecurity.wep_key0 = password;
+                settingSecurity.wep_tx_keyidx = 0;
+            } else if (securityType === SecurityType.WPA3_SAE) {
+                settingSecurity.key_mgmt = 'sae';
+                settingSecurity.psk = password;
+            } else {
+                settingSecurity.key_mgmt = 'wpa-psk';
+                settingSecurity.psk = password;
+            }
+
+            connection.add_setting(settingSecurity);
+
+            const settingIP4 = NM.SettingIP4Config.new();
+            settingIP4.method = 'auto';
+            connection.add_setting(settingIP4);
+
+            const settingIP6 = NM.SettingIP6Config.new();
+            settingIP6.method = 'auto';
+            connection.add_setting(settingIP6);
+
+            const activeConnection = await new Promise<NM.ActiveConnection>((resolve, reject) => {
+                this._nmClient.add_and_activate_connection_async(
+                    connection,
+                    wifiDevice,
+                    apPath,
+                    null,
+                    (client: NM.Client | null, result) => {
+                        try {
+                            if (client) {
+                                const activeConn = client.add_and_activate_connection_finish(result);
+                                resolve(activeConn);
+                            } else {
+                                reject(new Error('NetworkManager client is null'));
+                            }
+                        } catch (err) {
+                            reject(err);
+                        }
+                    },
+                );
             });
+
+            await this._waitForConnectionState(activeConnection);
+
+            this.connecting.set('');
+            this.staging.set(undefined);
+        } catch (err: unknown) {
+            this.connecting.set('');
+
+            const failedConn = this._nmClient.get_connection_by_id(ssid);
+            if (failedConn) {
+                failedConn.delete_async(null, () => {});
+            }
+
+            this._handleConnectionError(err, ssid, accessPoint);
+            throw err;
+        }
+    }
+
+    /**
+     * Classifies a NetworkManager state reason into an error type.
+     *
+     * @param stateReason - The NM.ActiveConnectionStateReason code.
+     * @returns The error type and user-friendly message.
+     */
+    private _classifyConnectionError(stateReason: NM.ActiveConnectionStateReason): {
+        type: ErrorType;
+        message: string;
+    } {
+        if (AUTH_STATE_REASONS.includes(stateReason)) {
+            return { type: ErrorType.AUTHENTICATION, message: 'Incorrect password.' };
+        }
+
+        if (stateReason === NM.ActiveConnectionStateReason.CONNECT_TIMEOUT) {
+            return { type: ErrorType.TIMEOUT, message: 'Connection timeout.' };
+        }
+
+        if (DEVICE_STATE_REASONS.includes(stateReason)) {
+            return { type: ErrorType.DEVICE, message: 'Device disconnected.' };
+        }
+
+        return {
+            type: ErrorType.OTHER,
+            message:
+                CONNECTION_ERROR_MESSAGES[stateReason] || `Connection failed (error code: ${stateReason}).`,
+        };
+    }
+
+    /**
+     * Checks if a device disconnection was caused by authentication failure.
+     *
+     * @param activeConnection - The active connection.
+     * @returns True if authentication failed.
+     */
+    private _isDeviceAuthFailure(activeConnection: NM.ActiveConnection): boolean {
+        const device = activeConnection.get_devices()[0] as NM.DeviceWifi | undefined;
+        if (!device) {
+            return false;
+        }
+
+        const deviceStateReason = device.get_state_reason();
+        return AUTH_DEVICE_REASONS.includes(deviceStateReason);
+    }
+
+    /**
+     * Waits for an active connection to reach ACTIVATED state or fail.
+     * This is necessary because add_and_activate returns before authentication completes.
+     *
+     * @param activeConnection - The active connection to monitor.
+     * @param ssid - The SSID for error messages.
+     */
+    private async _waitForConnectionState(activeConnection: NM.ActiveConnection): Promise<void> {
+        return new Promise((resolve, reject) => {
+            // eslint-disable-next-line prefer-const
+            let timeoutId: number | undefined;
+            // eslint-disable-next-line prefer-const
+            let stateHandlerId: number | undefined;
+
+            const cleanup = (): void => {
+                if (timeoutId) {
+                    clearTimeout(timeoutId);
+                }
+                if (stateHandlerId && activeConnection) {
+                    activeConnection.disconnect(stateHandlerId);
+                }
+            };
+
+            // Set timeout for connection attempt (30 seconds)
+            timeoutId = setTimeout(() => {
+                cleanup();
+                reject(new Error('Connection timeout'));
+            }, 30000) as unknown as number;
+
+            // Monitor state changes
+            stateHandlerId = activeConnection.connect('notify::state', () => {
+                const state = activeConnection.get_state();
+
+                if (state === NM.ActiveConnectionState.ACTIVATED) {
+                    cleanup();
+                    resolve();
+                } else if (
+                    state === NM.ActiveConnectionState.DEACTIVATED ||
+                    state === NM.ActiveConnectionState.DEACTIVATING
+                ) {
+                    cleanup();
+                    const stateReason = activeConnection.get_state_reason();
+                    let errorResult = this._classifyConnectionError(stateReason);
+
+                    // Device disconnections may be authentication failures - check device state
+                    if (
+                        errorResult.type === ErrorType.DEVICE &&
+                        this._isDeviceAuthFailure(activeConnection)
+                    ) {
+                        errorResult = { type: ErrorType.AUTHENTICATION, message: 'Incorrect password.' };
+                    }
+
+                    reject(new Error(errorResult.message));
+                }
+            }) as unknown as number;
+        });
+    }
+
+    /**
+     * Determines if an error message indicates an authentication failure.
+     *
+     * @param errorMessage - The error message to check.
+     * @returns True if authentication failed.
+     */
+    private _isAuthenticationError(errorMessage: string): boolean {
+        const authKeywords = ['incorrect password', 'authentication', 'secret', 'password'];
+        const lowerMessage = errorMessage.toLowerCase();
+        return authKeywords.some((keyword) => lowerMessage.includes(keyword));
+    }
+
+    /**
+     * Handles connection errors and provides user-friendly feedback.
+     *
+     * @param err - The error object.
+     * @param ssid - The SSID of the network.
+     * @param accessPoint - The access point being connected to.
+     */
+    private _handleConnectionError(err: unknown, ssid: string, accessPoint: AstalNetwork.AccessPoint): void {
+        const error = err as Error;
+        const errorMessage = error.message || 'Unknown error';
+
+        // Re-stage access point for password retry on authentication failures
+        if (this._isAuthenticationError(errorMessage)) {
+            this.staging.set(accessPoint);
+        }
+
+        SystemUtilities.notify({
+            summary: 'Failed to connect',
+            body: `"${ssid}": ${errorMessage}`,
+        });
     }
 
     /**
@@ -280,28 +833,30 @@ export class WifiManager {
             return;
         }
 
-        this.connecting.set(accessPoint.bssid || '');
-        execAsync('nmcli connection show --active').then((res: string) => {
-            const connectionId = this._getIdFromSsid(accessPoint.ssid || '', res);
+        const ssid = accessPoint.ssid;
+        if (!ssid) {
+            return;
+        }
 
-            if (connectionId === undefined) {
-                console.error(`Error while disconnecting "${accessPoint.ssid}": Connection ID not found`);
-                return;
-            }
+        this.connecting.set(accessPoint.bssid || '');
 
-            execAsync(`nmcli connection down ${connectionId} "${accessPoint.ssid}"`)
-                .then(() => {
-                    this.connecting.set('');
-                })
-                .catch((err: unknown) => {
-                    this.connecting.set('');
-                    console.error(`Error while disconnecting "${accessPoint.ssid}": ${err}`);
+        this._deactivateConnection(ssid)
+            .then(() => {
+                this.connecting.set('');
+            })
+            .catch((err: Error) => {
+                this.connecting.set('');
+                console.error(`Error while disconnecting "${ssid}": ${err.message}`);
+                SystemUtilities.notify({
+                    summary: 'Failed to disconnect',
+                    body: `"${ssid}": ${err.message}`,
                 });
-        });
+            });
     }
 
     /**
      * Forgets the specified access point by deleting its connection.
+     * Works with both active and saved (inactive) networks.
      *
      * @param accessPoint - The access point to forget.
      * @param event - The click event triggering the forget action.
@@ -310,42 +865,47 @@ export class WifiManager {
         if (!isPrimaryClick(event)) {
             return;
         }
-        this.connecting.set(accessPoint.bssid || '');
-        execAsync('nmcli connection show --active').then((res: string) => {
-            const connectionId = this._getIdFromSsid(accessPoint.ssid || '', res);
 
-            if (connectionId === undefined) {
-                console.error(`Error while forgetting "${accessPoint.ssid}": Connection ID not found`);
-                return;
-            }
+        const ssid = accessPoint.ssid;
+        if (!ssid) {
+            return;
+        }
 
-            execAsync(`nmcli connection delete ${connectionId} "${accessPoint.ssid}"`)
-                .then(() => {
-                    this.connecting.set('');
-                })
-                .catch((err: unknown) => {
-                    this.connecting.set('');
-                    console.error(`Error while forgetting "${accessPoint.ssid}": ${err}`);
-                });
-        });
-    }
+        this.connecting.set(accessPoint.bssid || '');
 
-    /**
-     * Extracts the connection ID associated with a given SSID from the `nmcli` command output.
-     *
-     * @param ssid - The SSID of the network.
-     * @param nmcliOutput - The output string from the `nmcli` command.
-     * @returns The connection ID if found; otherwise, undefined.
-     */
-    private _getIdFromSsid(ssid: string, nmcliOutput: string): string | undefined {
-        const lines = nmcliOutput.trim().split('\n');
+        // Find connection by SSID
+        const connection = this._nmClient.get_connection_by_id(ssid);
 
-        for (const line of lines) {
-            const columns = line.trim().split(/\s{2,}/);
+        if (!connection) {
+            this.connecting.set('');
+            console.error(`Error while forgetting "${ssid}": Connection not found`);
+            SystemUtilities.notify({
+                summary: 'Failed to remove network',
+                body: `"${ssid}": Connection not found`,
+            });
+            return;
+        }
 
-            if (columns[0].includes(ssid)) {
-                return columns[1];
+        // Delete connection
+        connection.delete_async(null, (conn: NM.RemoteConnection | null, result) => {
+            try {
+                if (conn) {
+                    conn.delete_finish(result);
+                }
+                this.connecting.set('');
+                SystemUtilities.notify({
+                    summary: 'Network',
+                    body: `Removed saved network "${ssid}"`,
+                });
+            } catch (err) {
+                this.connecting.set('');
+                const error = err as Error;
+                console.error(`Error while forgetting "${ssid}": ${error.message}`);
+                SystemUtilities.notify({
+                    summary: 'Failed to remove network',
+                    body: `Failed to remove "${ssid}": ${error.message}`,
+                });
             }
-        }
+        });
     }
 }
-- 
2.51.2

